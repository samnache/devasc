# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_network_automation_engineer_network_automation__network_automation_engineers_network_automation_engineer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module network_automation - based on the path /network_automation_engineers/network_automation_engineer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__username','__first_name','__last_name','__nickname',)

  _yang_name = 'network_automation_engineer'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)
    self.__first_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[A-Z][a-z0-9_-]{1,19}$'}), is_leaf=True, yang_name="first_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='name', is_config=True)
    self.__last_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[A-Z][a-z0-9_-]{1,19}$'}), is_leaf=True, yang_name="last_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='name', is_config=True)
    self.__nickname = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="nickname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network_automation_engineers', 'network_automation_engineer']

  def _get_username(self):
    """
    Getter method for username, mapped from YANG variable /network_automation_engineers/network_automation_engineer/username (string)
    """
    return self.__username
      
  def _set_username(self, v, load=False):
    """
    Setter method for username, mapped from YANG variable /network_automation_engineers/network_automation_engineer/username (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_username() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """username must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)""",
        })

    self.__username = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_username(self):
    self.__username = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)


  def _get_first_name(self):
    """
    Getter method for first_name, mapped from YANG variable /network_automation_engineers/network_automation_engineer/first_name (name)
    """
    return self.__first_name
      
  def _set_first_name(self, v, load=False):
    """
    Setter method for first_name, mapped from YANG variable /network_automation_engineers/network_automation_engineer/first_name (name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_first_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_first_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[A-Z][a-z0-9_-]{1,19}$'}), is_leaf=True, yang_name="first_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """first_name must be of a type compatible with name""",
          'defined-type': "network_automation:name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[A-Z][a-z0-9_-]{1,19}$'}), is_leaf=True, yang_name="first_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='name', is_config=True)""",
        })

    self.__first_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_first_name(self):
    self.__first_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[A-Z][a-z0-9_-]{1,19}$'}), is_leaf=True, yang_name="first_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='name', is_config=True)


  def _get_last_name(self):
    """
    Getter method for last_name, mapped from YANG variable /network_automation_engineers/network_automation_engineer/last_name (name)
    """
    return self.__last_name
      
  def _set_last_name(self, v, load=False):
    """
    Setter method for last_name, mapped from YANG variable /network_automation_engineers/network_automation_engineer/last_name (name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_name() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[A-Z][a-z0-9_-]{1,19}$'}), is_leaf=True, yang_name="last_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_name must be of a type compatible with name""",
          'defined-type': "network_automation:name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[A-Z][a-z0-9_-]{1,19}$'}), is_leaf=True, yang_name="last_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='name', is_config=True)""",
        })

    self.__last_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_name(self):
    self.__last_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[A-Z][a-z0-9_-]{1,19}$'}), is_leaf=True, yang_name="last_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='name', is_config=True)


  def _get_nickname(self):
    """
    Getter method for nickname, mapped from YANG variable /network_automation_engineers/network_automation_engineer/nickname (string)
    """
    return self.__nickname
      
  def _set_nickname(self, v, load=False):
    """
    Setter method for nickname, mapped from YANG variable /network_automation_engineers/network_automation_engineer/nickname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nickname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nickname() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="nickname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nickname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="nickname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)""",
        })

    self.__nickname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nickname(self):
    self.__nickname = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="nickname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)

  username = __builtin__.property(_get_username, _set_username)
  first_name = __builtin__.property(_get_first_name, _set_first_name)
  last_name = __builtin__.property(_get_last_name, _set_last_name)
  nickname = __builtin__.property(_get_nickname, _set_nickname)


  _pyangbind_elements = OrderedDict([('username', username), ('first_name', first_name), ('last_name', last_name), ('nickname', nickname), ])


class yc_network_automation_engineers_network_automation__network_automation_engineers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module network_automation - based on the path /network_automation_engineers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_automation_engineer',)

  _yang_name = 'network_automation_engineers'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_automation_engineer = YANGDynClass(base=YANGListType("username",yc_network_automation_engineer_network_automation__network_automation_engineers_network_automation_engineer, yang_name="network_automation_engineer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='username', extensions=None), is_container='list', yang_name="network_automation_engineer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network_automation_engineers']

  def _get_network_automation_engineer(self):
    """
    Getter method for network_automation_engineer, mapped from YANG variable /network_automation_engineers/network_automation_engineer (list)
    """
    return self.__network_automation_engineer
      
  def _set_network_automation_engineer(self, v, load=False):
    """
    Setter method for network_automation_engineer, mapped from YANG variable /network_automation_engineers/network_automation_engineer (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_automation_engineer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_automation_engineer() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("username",yc_network_automation_engineer_network_automation__network_automation_engineers_network_automation_engineer, yang_name="network_automation_engineer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='username', extensions=None), is_container='list', yang_name="network_automation_engineer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_automation_engineer must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("username",yc_network_automation_engineer_network_automation__network_automation_engineers_network_automation_engineer, yang_name="network_automation_engineer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='username', extensions=None), is_container='list', yang_name="network_automation_engineer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)""",
        })

    self.__network_automation_engineer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_automation_engineer(self):
    self.__network_automation_engineer = YANGDynClass(base=YANGListType("username",yc_network_automation_engineer_network_automation__network_automation_engineers_network_automation_engineer, yang_name="network_automation_engineer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='username', extensions=None), is_container='list', yang_name="network_automation_engineer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)

  network_automation_engineer = __builtin__.property(_get_network_automation_engineer, _set_network_automation_engineer)


  _pyangbind_elements = OrderedDict([('network_automation_engineer', network_automation_engineer), ])


class yc_network_automation_project_network_automation__network_automation_projects_network_automation_project(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module network_automation - based on the path /network_automation_projects/network_automation_project. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__project_name','__project_type','__owner',)

  _yang_name = 'network_automation_project'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__project_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="project_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)
    self.__project_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'internal': {}, 'external': {}},), is_leaf=True, yang_name="project_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='sjn_pt:project_type', is_config=True)
    self.__owner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network_automation_projects', 'network_automation_project']

  def _get_project_name(self):
    """
    Getter method for project_name, mapped from YANG variable /network_automation_projects/network_automation_project/project_name (string)
    """
    return self.__project_name
      
  def _set_project_name(self, v, load=False):
    """
    Setter method for project_name, mapped from YANG variable /network_automation_projects/network_automation_project/project_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_project_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_project_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="project_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """project_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="project_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)""",
        })

    self.__project_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_project_name(self):
    self.__project_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="project_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)


  def _get_project_type(self):
    """
    Getter method for project_type, mapped from YANG variable /network_automation_projects/network_automation_project/project_type (sjn_pt:project_type)
    """
    return self.__project_type
      
  def _set_project_type(self, v, load=False):
    """
    Setter method for project_type, mapped from YANG variable /network_automation_projects/network_automation_project/project_type (sjn_pt:project_type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_project_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_project_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'internal': {}, 'external': {}},), is_leaf=True, yang_name="project_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='sjn_pt:project_type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """project_type must be of a type compatible with sjn_pt:project_type""",
          'defined-type': "sjn_pt:project_type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'internal': {}, 'external': {}},), is_leaf=True, yang_name="project_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='sjn_pt:project_type', is_config=True)""",
        })

    self.__project_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_project_type(self):
    self.__project_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'internal': {}, 'external': {}},), is_leaf=True, yang_name="project_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='sjn_pt:project_type', is_config=True)


  def _get_owner(self):
    """
    Getter method for owner, mapped from YANG variable /network_automation_projects/network_automation_project/owner (leafref)
    """
    return self.__owner
      
  def _set_owner(self, v, load=False):
    """
    Setter method for owner, mapped from YANG variable /network_automation_projects/network_automation_project/owner (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_owner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_owner() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """owner must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='leafref', is_config=True)""",
        })

    self.__owner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_owner(self):
    self.__owner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='leafref', is_config=True)

  project_name = __builtin__.property(_get_project_name, _set_project_name)
  project_type = __builtin__.property(_get_project_type, _set_project_type)
  owner = __builtin__.property(_get_owner, _set_owner)


  _pyangbind_elements = OrderedDict([('project_name', project_name), ('project_type', project_type), ('owner', owner), ])


class yc_network_automation_projects_network_automation__network_automation_projects(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module network_automation - based on the path /network_automation_projects. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_automation_project',)

  _yang_name = 'network_automation_projects'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_automation_project = YANGDynClass(base=YANGListType("project_name",yc_network_automation_project_network_automation__network_automation_projects_network_automation_project, yang_name="network_automation_project", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='project_name', extensions=None), is_container='list', yang_name="network_automation_project", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network_automation_projects']

  def _get_network_automation_project(self):
    """
    Getter method for network_automation_project, mapped from YANG variable /network_automation_projects/network_automation_project (list)
    """
    return self.__network_automation_project
      
  def _set_network_automation_project(self, v, load=False):
    """
    Setter method for network_automation_project, mapped from YANG variable /network_automation_projects/network_automation_project (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_automation_project is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_automation_project() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("project_name",yc_network_automation_project_network_automation__network_automation_projects_network_automation_project, yang_name="network_automation_project", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='project_name', extensions=None), is_container='list', yang_name="network_automation_project", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_automation_project must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("project_name",yc_network_automation_project_network_automation__network_automation_projects_network_automation_project, yang_name="network_automation_project", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='project_name', extensions=None), is_container='list', yang_name="network_automation_project", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)""",
        })

    self.__network_automation_project = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_automation_project(self):
    self.__network_automation_project = YANGDynClass(base=YANGListType("project_name",yc_network_automation_project_network_automation__network_automation_projects_network_automation_project, yang_name="network_automation_project", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='project_name', extensions=None), is_container='list', yang_name="network_automation_project", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)

  network_automation_project = __builtin__.property(_get_network_automation_project, _set_network_automation_project)


  _pyangbind_elements = OrderedDict([('network_automation_project', network_automation_project), ])


class yc_repo_network_automation__repos_repo(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module network_automation - based on the path /repos/repo. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__repo_name','__owner',)

  _yang_name = 'repo'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__repo_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="repo_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)
    self.__owner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['repos', 'repo']

  def _get_repo_name(self):
    """
    Getter method for repo_name, mapped from YANG variable /repos/repo/repo_name (string)
    """
    return self.__repo_name
      
  def _set_repo_name(self, v, load=False):
    """
    Setter method for repo_name, mapped from YANG variable /repos/repo/repo_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repo_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repo_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="repo_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repo_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="repo_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)""",
        })

    self.__repo_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repo_name(self):
    self.__repo_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="repo_name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='string', is_config=True)


  def _get_owner(self):
    """
    Getter method for owner, mapped from YANG variable /repos/repo/owner (leafref)
    """
    return self.__owner
      
  def _set_owner(self, v, load=False):
    """
    Setter method for owner, mapped from YANG variable /repos/repo/owner (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_owner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_owner() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """owner must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='leafref', is_config=True)""",
        })

    self.__owner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_owner(self):
    self.__owner = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="owner", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='leafref', is_config=True)

  repo_name = __builtin__.property(_get_repo_name, _set_repo_name)
  owner = __builtin__.property(_get_owner, _set_owner)


  _pyangbind_elements = OrderedDict([('repo_name', repo_name), ('owner', owner), ])


class yc_repos_network_automation__repos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module network_automation - based on the path /repos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__repo',)

  _yang_name = 'repos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__repo = YANGDynClass(base=YANGListType("repo_name",yc_repo_network_automation__repos_repo, yang_name="repo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='repo_name', extensions=None), is_container='list', yang_name="repo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['repos']

  def _get_repo(self):
    """
    Getter method for repo, mapped from YANG variable /repos/repo (list)
    """
    return self.__repo
      
  def _set_repo(self, v, load=False):
    """
    Setter method for repo, mapped from YANG variable /repos/repo (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repo() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("repo_name",yc_repo_network_automation__repos_repo, yang_name="repo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='repo_name', extensions=None), is_container='list', yang_name="repo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repo must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("repo_name",yc_repo_network_automation__repos_repo, yang_name="repo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='repo_name', extensions=None), is_container='list', yang_name="repo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)""",
        })

    self.__repo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repo(self):
    self.__repo = YANGDynClass(base=YANGListType("repo_name",yc_repo_network_automation__repos_repo, yang_name="repo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='repo_name', extensions=None), is_container='list', yang_name="repo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='list', is_config=True)

  repo = __builtin__.property(_get_repo, _set_repo)


  _pyangbind_elements = OrderedDict([('repo', repo), ])


class network_automation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module network_automation - based on the path /network_automation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_automation_engineers','__network_automation_projects','__repos',)

  _yang_name = 'network_automation'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_automation_engineers = YANGDynClass(base=yc_network_automation_engineers_network_automation__network_automation_engineers, is_container='container', yang_name="network_automation_engineers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)
    self.__network_automation_projects = YANGDynClass(base=yc_network_automation_projects_network_automation__network_automation_projects, is_container='container', yang_name="network_automation_projects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)
    self.__repos = YANGDynClass(base=yc_repos_network_automation__repos, is_container='container', yang_name="repos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_automation_engineers(self):
    """
    Getter method for network_automation_engineers, mapped from YANG variable /network_automation_engineers (container)
    """
    return self.__network_automation_engineers
      
  def _set_network_automation_engineers(self, v, load=False):
    """
    Setter method for network_automation_engineers, mapped from YANG variable /network_automation_engineers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_automation_engineers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_automation_engineers() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_automation_engineers_network_automation__network_automation_engineers, is_container='container', yang_name="network_automation_engineers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_automation_engineers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_automation_engineers_network_automation__network_automation_engineers, is_container='container', yang_name="network_automation_engineers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)""",
        })

    self.__network_automation_engineers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_automation_engineers(self):
    self.__network_automation_engineers = YANGDynClass(base=yc_network_automation_engineers_network_automation__network_automation_engineers, is_container='container', yang_name="network_automation_engineers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)


  def _get_network_automation_projects(self):
    """
    Getter method for network_automation_projects, mapped from YANG variable /network_automation_projects (container)
    """
    return self.__network_automation_projects
      
  def _set_network_automation_projects(self, v, load=False):
    """
    Setter method for network_automation_projects, mapped from YANG variable /network_automation_projects (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_automation_projects is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_automation_projects() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_automation_projects_network_automation__network_automation_projects, is_container='container', yang_name="network_automation_projects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_automation_projects must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_automation_projects_network_automation__network_automation_projects, is_container='container', yang_name="network_automation_projects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)""",
        })

    self.__network_automation_projects = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_automation_projects(self):
    self.__network_automation_projects = YANGDynClass(base=yc_network_automation_projects_network_automation__network_automation_projects, is_container='container', yang_name="network_automation_projects", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)


  def _get_repos(self):
    """
    Getter method for repos, mapped from YANG variable /repos (container)
    """
    return self.__repos
      
  def _set_repos(self, v, load=False):
    """
    Setter method for repos, mapped from YANG variable /repos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repos() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_repos_network_automation__repos, is_container='container', yang_name="repos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """repos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_repos_network_automation__repos, is_container='container', yang_name="repos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)""",
        })

    self.__repos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_repos(self):
    self.__repos = YANGDynClass(base=yc_repos_network_automation__repos, is_container='container', yang_name="repos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://sjn.network/ns/network_automation', defining_module='network_automation', yang_type='container', is_config=True)

  network_automation_engineers = __builtin__.property(_get_network_automation_engineers, _set_network_automation_engineers)
  network_automation_projects = __builtin__.property(_get_network_automation_projects, _set_network_automation_projects)
  repos = __builtin__.property(_get_repos, _set_repos)


  _pyangbind_elements = OrderedDict([('network_automation_engineers', network_automation_engineers), ('network_automation_projects', network_automation_projects), ('repos', repos), ])


